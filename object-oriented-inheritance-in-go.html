<!DOCTYPE html>
<html lang="en">
  <head>
        <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=endge, chrome=IE8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=no" />
    <title> Object Oriented Inheritance in Go </title>
    <link href='https://fonts.googleapis.com/css?family=Alice' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Lora:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
    <!--[if lte IE 8]><script type="text/javascript" src="https://hackthology.com/theme/js/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" type="text/css" href="https://hackthology.com/theme/css/skeleton.css" />
    <link rel="stylesheet" type="text/css" href="https://hackthology.com/theme/css/theme.css" />
    <link rel="shortcut icon" type="image/png" href="https://hackthology.com/favicon.png" />
    <!--[if lte IE 8]><link rel="shortcut icon" type="image/x-icon" href="https://hackthology.com/favicon.ico" /><![endif]-->
    <link rel="alternate" type="application/atom+xml"
                           title="Hackthology — Flux Atom"
                           href="https://hackthology.com/" /> 
    <link rel ="alternate" type="application/rss+xml"
                           title="Hackthology — Flux RSS"
                           href="https://hackthology.com/feeds/rss.xml" /> 
    <link rel="canonical" href="https://hackthology.com/object-oriented-inheritance-in-go.html"/>
    <meta name="keywords" content="" />
    <link rel="stylesheet" media="not print" type="text/css" href="https://hackthology.com/theme/css/pygments.css" /> 
  </head>
  <body>
    <div id="page">
      <header id="page-head">
        <h1>
          <a href="https://hackthology.com/index.html">Hackthology</a>
        </h1>
        <h3>
          The Discourses of Tim Henderson
        </h3>
        <div class="top-nav">
<ul>
    <li><a href="https://hackthology.com/articles.html">articles</a></li>
    <li><a href="https://hackthology.com/pages/about.html">about</a></li>
    <li><a href="https://hackthology.com/pages/publications.html">publications</a></li>
    <li><a href="https://hackthology.com/pages/projects.html">projects</a></li>
    <li><a href="https://hackthology.com/pages/teaching.html">teaching</a></li>
</ul>
<ul>
    <li><a href="https://hackthology.com/feeds/rss.xml">rss-feed</a></li>
    <li><a href="https://github.com/timtadh">github</a></li>
    <li><a href="https://twitter.com/timtadh">twitter</a></li>
    <li><a href="https://plus.google.com/109232399292705173597">google+</a></li>
    <li><a href="https://keybase.io/tadh">keybase</a></li>
</ul></div>
      </header>
      
      <div id="page-body">

        <article class="post" id="page-main" role="main">
      <header class="post-header">
        <h1 class="full">
          <a rel="bookmark"
             href="https://hackthology.com/object-oriented-inheritance-in-go.html"
             title="perm link Object Oriented Inheritance in Go">
             Object Oriented Inheritance in Go
          </a>
        </h1>
        <div class="meta">
<!-- includes/article_meta.html -->
          <div class="meta">
            by &nbsp;Tim Henderson
<br/> <time datetime="2016-05-20T00:00:00-04:00">Fri 20 May 2016</time></div>        </div>
      </header>
      <div class="post-content"> 
        <p>The Go (golang) programming language is not a traditional object oriented
language like Smalltalk or Java. A key feature supporting traditional object
oriented design is inheritance.  Inheritance supports sharing of code and data
between related objects. It used to be that inheritance was the dominant design
for sharing code and data but today another (older) technique called composition
has seen a resurgence.</p>
<blockquote>
<p>Thank you 李浩 (Hao Li) for translating this article into Mandarin:
<a href="/golangzhong-de-mian-xiang-dui-xiang-ji-cheng.html" title="Golang中的面向对象继承">Golang中的面向对象继承</a></p>
</blockquote>
<p>Before we jump into how to use inheritance in Go (which has some interesting
edge cases) let's see how it is used in Java.</p>
<h3>Inheritance vs. Composition in Java</h3>
<p>Let's look at an example from one of my favorite topics: compilers! A compiler
is made up of a pipeline of transformations that take "plain text" and transform
it either to machine code, assembly language, bytecode, or another programming
language. The first stage of the pipeline the <em>lexer</em> performs what is called
<em>lexical analysis</em> of the programming language. It traditionally splits the text
up into the different components as: keywords, identifiers, punctuation,
numbers, etc... Each component is tagged with the class of component it is. So
for this fragment of Java:</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{}</span>
</pre></div>


<p>The "components" (called <em>tokens</em>) would be:</p>
<div class="highlight"><pre><span></span>&lt;public keyword&gt;, &quot;public&quot;
&lt;class keyword&gt;, &quot;class&quot;
&lt;idenitifier&gt;, &quot;Main&quot;
&lt;left-bracket&gt;, &quot;{&quot;
&lt;right-bracket&gt;, &quot;}&quot;
</pre></div>


<p>The tokens have two parts:</p>
<ol>
<li>The <em>token type</em></li>
<li>The <em>lexeme</em>, or the string the token was extracted from</li>
</ol>
<p>This leads to the following Java design</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">enum</span> <span class="n">TokenType</span> <span class="o">{</span>
    <span class="n">KEYWORD</span><span class="o">,</span> <span class="n">IDENTIFIER</span><span class="o">,</span> <span class="n">LBRACKET</span><span class="o">,</span> <span class="n">RBRACKET</span><span class="o">,</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Token</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">TokenToken</span> <span class="n">type</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">lexeme</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>For some tokens, such as numeric constants, it is convenient to specialize the
<code>Token</code> object to contain some extra information. In the case of numeric
constants the numerical value of the lexeme is convenient to store directly in
the <code>Token</code>. The traditional way to accomplish this is to have the numeric
tokens <em>inherit</em> from the <code>Token</code> class.</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntegerConstant</span> <span class="kd">extends</span> <span class="n">Token</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>Another way this can be achieved is to use composition where the <code>IntegerConstant</code>
instead of extending the <code>Token</code> class contains a reference to the token.</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntegerConstant</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Token</span> <span class="n">type</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>It turns out, in this particular case, inheritance is the better choice. The
reason is the <code>Lexer</code> which produces the tokens needs to return a common type.
Consider the interface of the Lexer:</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lexer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Lexer</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">in</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">EOF</span><span class="o">()</span>
    <span class="kd">public</span> <span class="n">Token</span> <span class="nf">peek</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Error</span>
    <span class="kd">public</span> <span class="n">Token</span> <span class="nf">next</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Error</span>
<span class="o">}</span>
</pre></div>


<p>Since in the first design (which uses inheritance) a <code>IntegerConstant</code> <em>is a</em>
<code>Token</code> it can be used in the Lexer. Now, this isn't the only design that can be
used and maybe isn't even the best design but it is valid. Let's take a look at
how it translates to into Go.</p>
<h3>Inheritance and Composition in Go</h3>
<p>Composition is very natural in Go (as it is in most languages). To compose two
structures simply provide a pointer or embedding to the collaborating structure.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">TokenType</span> <span class="kt">uint16</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">KEYWORD</span> <span class="nx">TokenType</span> <span class="p">=</span> <span class="kc">iota</span>
    <span class="nx">IDENTIFIER</span>
    <span class="nx">LBRACKET</span>
    <span class="nx">RBRACKET</span>
    <span class="nx">INT</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Token</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Type</span>   <span class="nx">TokenType</span>
  <span class="nx">Lexeme</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">IntegerConstant</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Token</span> <span class="o">*</span><span class="nx">Token</span>
  <span class="nx">Value</span> <span class="kt">uint64</span>
<span class="p">}</span>
</pre></div>


<p>This would be the usual way to share code and data in Go. However, if you feel
the need for inheritance then how can we use it?</p>
<h4>Why would you want to use inheritance in go?</h4>
<p>One of the obvious alternative designs for the <code>Token</code> is to make it an
interface. This works equally well in both Java and Go:</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Token</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nx">Type</span><span class="p">()</span>   <span class="nx">TokenType</span>
  <span class="nx">Lexeme</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Match</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">toktype</span> <span class="nx">TokenType</span>
  <span class="nx">lexeme</span>  <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">IntegerConstant</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">token</span> <span class="nx">Token</span>
  <span class="nx">value</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Match</span><span class="p">)</span> <span class="nx">Type</span><span class="p">()</span> <span class="nx">TokenType</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">toktype</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Match</span><span class="p">)</span> <span class="nx">Lexeme</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">lexeme</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IntegerConstant</span><span class="p">)</span> <span class="nx">Type</span><span class="p">()</span> <span class="nx">TokenType</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">token</span><span class="p">.</span><span class="nx">Type</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IntegerConstant</span><span class="p">)</span> <span class="nx">Lexeme</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">token</span><span class="p">.</span><span class="nx">Lexeme</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IntegerConstant</span><span class="p">)</span> <span class="nx">Value</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">value</span>
<span class="p">}</span>
</pre></div>


<p>The Lexer can then easily return the <code>Token</code> interface which both <code>*Match</code> and
<code>*IntegerConstant</code> satisfy.</p>
<h4>Simplifying with inheritance</h4>
<p>One of the problems with the previous design is the manual work in
<code>*IntegerConstant</code> calling <code>i.token.Type()</code> and <code>i.token.Lexeme()</code>. It turns out
we can use Go's built in support for
<a href="https://twitter.com/hackthology"><em>embedding</em></a> to avoid this work. Embedding is
a limited form of inheritance which allows types to share data and code.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">IntegerConstant</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Token</span>
  <span class="nx">value</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IntegerConstant</span><span class="p">)</span> <span class="nx">Value</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">value</span>
<span class="p">}</span>
</pre></div>


<p>By not giving the <code>Token</code> field a name in <code>IntegerConstant</code>, it "inherits" the
methods (and fields if <code>Token</code> was a <code>struct</code>) from <code>Token</code>. This pretty cool!
We can write code like this:</p>
<div class="highlight"><pre><span></span><span class="nx">t</span> <span class="o">:=</span> <span class="nx">IntegerConstant</span><span class="p">{</span><span class="o">&amp;</span><span class="nx">Match</span><span class="p">{</span><span class="nx">KEYWORD</span><span class="p">,</span> <span class="s">&quot;wizard&quot;</span><span class="p">},</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Type</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Lexeme</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Value</span><span class="p">())</span>
<span class="nx">x</span> <span class="o">:=</span> <span class="nx">Token</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">Type</span><span class="p">(),</span> <span class="nx">x</span><span class="p">.</span><span class="nx">Lexeme</span><span class="p">())</span>
</pre></div>


<p>(try it in the playground <a href="https://play.golang.org/p/PJW7VShpE0">https://play.golang.org/p/PJW7VShpE0</a>)</p>
<p>So wow! Not only did we not have implement <code>Type()</code> and <code>Value()</code> but
<code>*IntegerConstant</code> also implements the <code>Token</code> interface. Pretty nice.</p>
<h4>"Inheriting" from <code>structs</code></h4>
<p>There are three ways to do "inheritance" in Go. You have already seen one,
"inheriting" from an <code>interface</code> by putting it as the first member without a field
name. It turns out your can do the same thing with <code>struct</code>s and you have two
choices</p>
<ol>
<li>
<p>Inherit by embedding the <code>struct</code> by value</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">IntegerConstant</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Match</span>
  <span class="nx">value</span> <span class="kt">uint64</span>
<span class="p">}</span>
</pre></div>


</li>
<li>
<p>Inherit by embedding a pointer to a <code>struct</code></p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">IntegerConstant</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">Match</span>
  <span class="nx">value</span> <span class="kt">uint64</span>
<span class="p">}</span>
</pre></div>


</li>
</ol>
<p>In all cases, the difference from a regular field is the lack of an explicit
name. However, the field still has a name. It is the name of the embedded type.
In the case of <code>IntegerConstant</code> the <code>Match</code> field is named <code>Match</code>. This is
true whether one embeds a pointer to a struct or a struct by value.</p>
<p>On gotcha of all of these options, you can't have a Field and a method with the
same name. A <code>struct</code> <code>Bar</code> is embedding a <code>struct</code> <code>Foo</code> precludes <code>Bar</code> from
having a method called <code>Foo</code>. It also prevents <code>Bar</code> from implementing <code>type
Fooer interface { Foo() }</code>.</p>
<h3>Sharing Data, Code or Both</h3>
<p>In Go the line between inheritance and composition is pretty blurry in
comparison with Java. There is no <code>extends</code> keyword. Syntactically, inheritance
looks almost identical to composition. The only difference between composition
and inheritance in Go, is a <code>struct</code> which inherits from another <code>struct</code> can
directly access the methods and fields of the parent <code>struct</code>.</p>
<div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Pet</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Pet</span>
  <span class="nx">Breed</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;my name is %v&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%v and I am a %v&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Pet</span><span class="p">.</span><span class="nx">Speak</span><span class="p">(),</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Breed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">d</span> <span class="o">:=</span> <span class="nx">Dog</span><span class="p">{</span><span class="nx">Pet</span><span class="p">:</span> <span class="nx">Pet</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&quot;spot&quot;</span><span class="p">},</span> <span class="nx">Breed</span><span class="p">:</span> <span class="s">&quot;pointer&quot;</span><span class="p">}</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>


<p>(try in the playground <a href="https://play.golang.org/p/Pmkd27Nqqy">https://play.golang.org/p/Pmkd27Nqqy</a>)</p>
<p><strong>Output</strong>:</p>
<div class="highlight"><pre><span></span>spot
my name is spot and I am a pointer
</pre></div>


<h3>Limitations of Embedding as Inheritance</h3>
<p>In comparison to a language like Java, Go's form of inheritance is quite
limited. There are multiple designs which can be easily accomplished in Java
which are not possible in Go. Let's look at some of them.</p>
<h4>Overriding Methods</h4>
<p>In the pet example above, <code>Dog</code> "overrides" the <code>Speak()</code> method. However, if
<code>Pet</code> had another method <code>Play()</code> which invokes <code>Speak()</code> that <code>Dog</code> does not
override the <code>Dog</code>'s implementation of <code>Speak()</code> would not be used:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Pet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Pet</span>
    <span class="nx">Breed</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Play</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;my name is %v&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%v and I am a %v&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Pet</span><span class="p">.</span><span class="nx">Speak</span><span class="p">(),</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Breed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">Dog</span><span class="p">{</span><span class="nx">Pet</span><span class="p">:</span> <span class="nx">Pet</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&quot;spot&quot;</span><span class="p">},</span> <span class="nx">Breed</span><span class="p">:</span> <span class="s">&quot;pointer&quot;</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">Play</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>(try it on the playground: <a href="https://play.golang.org/p/id-aDKW8L6">https://play.golang.org/p/id-aDKW8L6</a>)</p>
<p><strong>Output</strong>:</p>
<div class="highlight"><pre><span></span>spot
my name is spot and I am a pointer
my name is spot
</pre></div>


<p>Contrast this to Java, in Java it would work as expected!</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Dog</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">(</span><span class="s">&quot;spot&quot;</span><span class="o">,</span> <span class="s">&quot;pointer&quot;</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">Name</span><span class="o">());</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">Speak</span><span class="o">());</span>
    <span class="n">d</span><span class="o">.</span><span class="na">Play</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Pet</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Pet</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">Play</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Speak</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">Speak</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;my name is %s&quot;</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">Name</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Pet</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">breed</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Dog</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">String</span> <span class="n">breed</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">breed</span> <span class="o">=</span> <span class="n">breed</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">Speak</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;my name is %s and I am a %s&quot;</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">breed</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p><strong>Output</strong></p>
<div class="highlight"><pre><span></span>$ javac Main.java <span class="o">&amp;&amp;</span> java Main
spot
my name is spot and I am a pointer
my name is spot and I am a pointer
</pre></div>


<p>This is a pretty big difference as it essentially precludes the use of abstract
methods as you might want to define them. However, there is a work around:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Pet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">speaker</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">name</span>    <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Pet</span>
    <span class="nx">Breed</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewPet</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Pet</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Pet</span><span class="p">{</span>
        <span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">speaker</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">speak</span>
    <span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Play</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">speaker</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;my name is %v&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewDog</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">breed</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Dog</span> <span class="p">{</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Dog</span><span class="p">{</span>
        <span class="nx">Pet</span><span class="p">:</span>   <span class="nx">Pet</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">},</span>
        <span class="nx">Breed</span><span class="p">:</span> <span class="nx">breed</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">speaker</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">speak</span>
    <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nx">speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%v and I am a %v&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Pet</span><span class="p">.</span><span class="nx">speak</span><span class="p">(),</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Breed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">NewDog</span><span class="p">(</span><span class="s">&quot;spot&quot;</span><span class="p">,</span> <span class="s">&quot;pointer&quot;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">Play</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>(try it on the playground <a href="https://play.golang.org/p/9iIb2px7jH">https://play.golang.org/p/9iIb2px7jH</a>)</p>
<p><strong>Output</strong>:</p>
<div class="highlight"><pre><span></span>spot
my name is spot and I am a pointer
my name is spot and I am a pointer
</pre></div>


<p>Now, it works "as expected" but it is much more verbose and difficult than in
Java. You manually have to override the method yourself. Furthermore, it is
rather fragile because if the struct is initialized incorrectly it will crash
when <code>Speak()</code> is called because <code>speaker()</code> will not have been correctly
initialized.</p>
<h4>Subtyping</h4>
<p>In Java, when the class <code>Dog</code> extends <code>Pet</code> it <em>is</em> a <code>Pet</code>. That means in every
place you need an object of type <code>Pet</code> you can use a <code>Dog</code> object. <code>Dog</code> is
said to <em>substitute</em> for <code>Pet</code>. This relationship is known as <em>subtyping</em> (<code>Dog</code>
is a <em>subtype</em> of <code>Pet</code>). This relationship is also called subtype polymorphism
and it does not exist in the Go programming language for <code>struct</code> types.</p>
<p>Let's look at an example:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Pet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">speaker</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">name</span>    <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Pet</span>
    <span class="nx">Breed</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewPet</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Pet</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Pet</span><span class="p">{</span>
        <span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">speaker</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">speak</span>
    <span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Play</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">speaker</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;my name is %v&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="nx">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewDog</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">breed</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Dog</span> <span class="p">{</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Dog</span><span class="p">{</span>
        <span class="nx">Pet</span><span class="p">:</span>   <span class="nx">Pet</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">},</span>
        <span class="nx">Breed</span><span class="p">:</span> <span class="nx">breed</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">speaker</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">speak</span>
    <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nx">speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%v and I am a %v&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Pet</span><span class="p">.</span><span class="nx">speak</span><span class="p">(),</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Breed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Play</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pet</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Play</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">NewDog</span><span class="p">(</span><span class="s">&quot;spot&quot;</span><span class="p">,</span> <span class="s">&quot;pointer&quot;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
    <span class="nx">Play</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>(try it out on the playground <a href="https://play.golang.org/p/e1Ujx0VhwK">https://play.golang.org/p/e1Ujx0VhwK</a>)</p>
<p><strong>Output</strong>:</p>
<div class="highlight"><pre><span></span>prog.go:62: cannot use d (type *Dog) as type *Pet in argument to Play
</pre></div>


<p>However, not all is lost because subtyping does exist for <code>interface</code> types!
Let's try it out:</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Pet</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Name</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">Play</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">pet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">speaker</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nx">name</span>    <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Pet</span>
    <span class="nx">Breed</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">dog</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">pet</span>
    <span class="nx">breed</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewPet</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">pet</span> <span class="p">{</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pet</span><span class="p">{</span>
        <span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">speaker</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">speak</span>
    <span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pet</span><span class="p">)</span> <span class="nx">Play</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pet</span><span class="p">)</span> <span class="nx">Speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">speaker</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pet</span><span class="p">)</span> <span class="nx">speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;my name is %v&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">pet</span><span class="p">)</span> <span class="nx">Name</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">NewDog</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">breed</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">dog</span> <span class="p">{</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">dog</span><span class="p">{</span>
        <span class="nx">pet</span><span class="p">:</span>   <span class="nx">pet</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">},</span>
        <span class="nx">breed</span><span class="p">:</span> <span class="nx">breed</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">d</span><span class="p">.</span><span class="nx">speaker</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">speak</span>
    <span class="k">return</span> <span class="nx">d</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">dog</span><span class="p">)</span> <span class="nx">speak</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%v and I am a %v&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">pet</span><span class="p">.</span><span class="nx">speak</span><span class="p">(),</span> <span class="nx">d</span><span class="p">.</span><span class="nx">breed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Play</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Pet</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Play</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">NewDog</span><span class="p">(</span><span class="s">&quot;spot&quot;</span><span class="p">,</span> <span class="s">&quot;pointer&quot;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">())</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">Speak</span><span class="p">())</span>
    <span class="nx">Play</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>(try it on the playground <a href="https://play.golang.org/p/WMH-cr4AJf">https://play.golang.org/p/WMH-cr4AJf</a>)</p>
<p><strong>Output</strong>:</p>
<div class="highlight"><pre><span></span>spot
my name is spot and I am a pointer
my name is spot and I am a pointer
</pre></div>


<p>Thus, <code>interface</code>s can be used to acheive a form of subtyping. However, if they
do not change the equation on method overriding. If you want a method overridden
correctly you still have to use the "trick" I presented above.</p>
<h3>Conclusion</h3>
<p>So it turns out, while it isn't a headline feature of Go, its ability for
<code>struct</code>s to embed <code>struct</code> pointers, <code>struct</code>s, and <code>interface</code>s is powerful
and flexible. It allows innovative designs that can solve real problems.
However, in comparison to Java it is limited because of a lack of direct support
for subtyping and method overriding. It does contain one feature that Java does
not, the ability to embed an <code>interface</code>. For more details on embedding checkout
the <a href="https://golang.org/doc/effective_go.html#embedding">Embedding</a> section of
<a href="https://golang.org/doc/effective_go.html">Effective Go</a>.</p>
<hr />
<p>Thank you to echlebek, Alexander Staubo, spriggan3, and breerly for reading and
providing thoughtful feedback on this post.</p>
      </div>
      </article> <!-- /#page-main -->

      </div>  <!-- /#page-body -->

      <footer id="page-foot">
        <div class="bottom-nav">
<ul>
    <li><a href="https://hackthology.com/articles.html">articles</a></li>
    <li><a href="https://hackthology.com/pages/about.html">about</a></li>
    <li><a href="https://hackthology.com/pages/publications.html">publications</a></li>
    <li><a href="https://hackthology.com/pages/projects.html">projects</a></li>
    <li><a href="https://hackthology.com/pages/teaching.html">teaching</a></li>
</ul>
<ul>
    <li><a href="https://hackthology.com/feeds/rss.xml">rss-feed</a></li>
    <li><a href="https://github.com/timtadh">github</a></li>
    <li><a href="https://twitter.com/timtadh">twitter</a></li>
    <li><a href="https://plus.google.com/109232399292705173597">google+</a></li>
    <li><a href="https://keybase.io/tadh">keybase</a></li>
</ul></div>
        <p>Copyright 2016 Tim Henderson. All Rights Reserved.</p>
      </footer>
    </div> <!-- /#page -->
    <script type="text/javascript">
      var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-20145944-2']);
          _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); 
        ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>