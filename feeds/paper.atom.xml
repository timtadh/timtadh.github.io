<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Hackthology</title><link href="http://hackthology.com/" rel="alternate"></link><link href="http://hackthology.com/feeds/paper.atom.xml" rel="self"></link><id>http://hackthology.com/</id><updated>2017-01-03T00:00:00-05:00</updated><entry><title>Frequent Subgraph Mining of Personalized Signaling Pathway Networks Groups Patients with Frequently Dysregulated Disease Pathways and Predicts Prognosis.</title><link href="http://hackthology.com/frequent-subgraph-mining-of-personalized-signaling-pathway-networks-groups-patients-with-frequently-dysregulated-disease-pathways-and-predicts-prognosis.html" rel="alternate"></link><updated>2017-01-03T00:00:00-05:00</updated><author><name>Arda Durmaz, &lt;a href="http://hackthology.com"&gt;Tim Henderson&lt;/a&gt;, Doug Brubaker, and &lt;a href="http://gurkan.case.edu"&gt;Gurkan Bebek&lt;/a&gt;</name></author><id>tag:hackthology.com,2017-01-03:frequent-subgraph-mining-of-personalized-signaling-pathway-networks-groups-patients-with-frequently-dysregulated-disease-pathways-and-predicts-prognosis.html</id><summary type="html">&lt;p&gt;A. Durmaz*, &lt;strong&gt;T. A. D. Henderson&lt;/strong&gt;*, D.  Brubaker, and G. Bebek. &lt;em&gt;Frequent
Subgraph Mining of Personalized Signaling Pathway Networks Groups Patients with
Frequently Dysregulated Disease Pathways and Predicts Prognosis.&lt;/em&gt;
&lt;a href="http://psb.stanford.edu/"&gt;PSB 2017&lt;/a&gt;.
&lt;a href="http://hackthology.com/pdfs/psb-2017.pdf"&gt;PDF&lt;/a&gt;.
&lt;a href="http://hackthology.com/pdfs/psb-2017-supplemental.pdf"&gt;SUPPLEMENT&lt;/a&gt;.
&lt;a href="http://hackthology.com/frequent-subgraph-mining-of-personalized-signaling-pathway-networks-groups-patients-with-frequently-dysregulated-disease-pathways-and-predicts-prognosis.html"&gt;WEB&lt;/a&gt;. &lt;br/&gt;
* &lt;strong&gt;Co-First Author&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Abstract&lt;/h3&gt;
&lt;h4&gt;Motivation&lt;/h4&gt;
&lt;p&gt;Large scale genomics studies have generated comprehensive molecular
characterization of numerous cancer types. Subtypes for many tumor types have
been established; however, these classifications are based on molecular
characteristics of a small gene sets with limited power to detect dysregulation
at the patient level.  We hypothesize that frequent graph mining of pathways to
gather pathways functionally relevant to tumors can characterize tumor types and
provide opportunities for personalized therapies.&lt;/p&gt;
&lt;h4&gt;Results&lt;/h4&gt;
&lt;p&gt;In this study we present an integrative omics approach to group patients based
on their altered pathway characteristics and show prognostic differences within
breast cancer (p &amp;lt; 9.57e-10) and glioblastoma multiforme (p &amp;lt; 0.05) patients. We
were able validate this approach in secondary RNA-Seq datasets with p &amp;lt; 0.05 and
p &amp;lt; 0.01 respectively. We also performed pathway enrichment analysis to further
investigate the biological relevance of dysregulated pathways. We compared our
approach with network-based classifier algorithms and showed that our
unsupervised approach generates more robust and biologically relevant clustering
whereas previous approaches failed to report specific functions for similar
patient groups or classify patients into prognostic groups.&lt;/p&gt;
&lt;h4&gt;Conclusions&lt;/h4&gt;
&lt;p&gt;These results could serve as a means to improve
prognosis for future cancer patients, and to provide opportunities for
improved treatment options and personalized interventions.  The proposed novel 
graph mining approach is able to integrate PPI networks 
with gene expression in a biologically sound approach and cluster patients in to
clinically distinct groups. We have utilized breast cancer and glioblastoma
multiforme datasets from microarray and RNA-Seq platforms and identified
disease mechanisms differentiating samples.&lt;/p&gt;</summary></entry><entry><title>Sampling Code Clones from Program Dependence Graphs with GRAPLE</title><link href="http://hackthology.com/sampling-code-clones-from-program-dependence-graphs-with-graple.html" rel="alternate"></link><updated>2016-11-13T00:00:00-05:00</updated><author><name>&lt;a href="http://hackthology.com"&gt;Tim Henderson&lt;/a&gt; and &lt;a href="http://engineering.case.edu/profiles/hap"&gt;Andy Podgurski&lt;/a&gt;</name></author><id>tag:hackthology.com,2016-11-13:sampling-code-clones-from-program-dependence-graphs-with-graple.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Tim A. D. Henderson&lt;/strong&gt; and Andy Podgurski. &lt;em&gt;Sampling Code Clones from Program
Dependence Graphs with GRAPLE&lt;/em&gt;.
&lt;a href="http://softwareanalytics.ca/swan16/Home.html"&gt;SWAN 2016&lt;/a&gt;.
&lt;a href="https://dx.doi.org/10.1145/2989238.2989241"&gt;DOI&lt;/a&gt;.
&lt;a href="http://hackthology.com/pdfs/swan-2016.pdf"&gt;PDF&lt;/a&gt;.
&lt;a href="http://hackthology.com/pdfs/swan-2016-supplemental.pdf"&gt;SUPPLEMENT&lt;/a&gt;.
&lt;a href="https://github.com/timtadh/graple"&gt;CODE&lt;/a&gt;.
&lt;a href="http://hackthology.com/sampling-code-clones-from-program-dependence-graphs-with-graple.html"&gt;WEB&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;Abstract&lt;/h4&gt;
&lt;p&gt;We present &lt;a href="https://github.com/timtadh/graple"&gt;GRAPLE&lt;/a&gt;, a method to generate a
representative sample of recurring (frequent) subgraphs of any directed labeled
graph(s).  &lt;code&gt;GRAPLE&lt;/code&gt; is based on frequent subgraph mining, absorbing Markov
chains, and Horvitz-Thompson estimation. It can be used to sample any kind of
graph representation for programs. One of many software engineering applications
for finding recurring subgraphs is detecting duplicated code (code clones) from
representations such as program dependence graphs (PDGs) and abstract syntax
trees.  To assess the usefulness of clones detected from PDGs, we conducted a
case study on a 73 KLOC commercial Android application developed over 5 years.
Nine of the application's developers participated. To our knowledge, it is the
first study to have professional developers examine code clones detected from
PDGs.  We describe a new PDG generation tool
&lt;a href="https://github.com/timtadh/jpdg"&gt;jpdg&lt;/a&gt; for JVM languages, which was used to
generate the dependence graphs used in the study.&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Code clones&lt;/em&gt; are similar fragments of program code. They can arise from copying
and pasting, using certain design patterns or certain APIs, or adhering to
coding conventions, among other causes. Code clones create maintenance hazards,
because they often require subtle context-dependent adaptation and because other
changes must be applied to each member of a clone class. To manage clone
evolution the clones must first be found. Clones can be detected using any
program representation: source code text, tokens, abstract syntax trees (ASTs),
flow graphs, dependence graphs, etc. Each representation has advantages and
disadvantages for clone detection.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PDG-based clone detection&lt;/em&gt; finds &lt;em&gt;dependence clones&lt;/em&gt; corresponding to recurring
subgraphs of a program dependence graph (PDG).  Since PDGs are oblivious to
semantics preserving statement reorderings they are well suited to detect
&lt;em&gt;semantic&lt;/em&gt; (functionally equivalent) clones. A number of algorithms find clones
from PDGs.  However, as Bellon notes, "PDG based techniques are computationally
expensive and often report non-contiguous clones that may not be perceived as
clones by a human evaluator." Most PDG-based clone detection tools are biased,
detecting certain clones but not others.&lt;/p&gt;
&lt;p&gt;The root cause of scalability problems with PDG-based clone detection is the
number of dependence clones. The Background Section (in the
&lt;a href="http://hackthology.com/pdfs/swan-2016.pdf"&gt;pdf&lt;/a&gt;) illustrates this with an example in which
we used an unbiased frequent subgraph mining algorithm to detect all dependence
clones in Java programs. In programs with about 70 KLOC it detected around 10
million clones before disk space was exhausted. Processing all dependence clones
is impractical even for modestly sized programs.&lt;/p&gt;
&lt;p&gt;Instead of exhaustively enumerating all dependence clones, an unbiased random
sample can be used to statistically estimate parameters of the whole
"population" of clones, such as the prevalence of clones exhibiting properties
of interest.  For these reasons, we developed a statistically unbiased method
for &lt;em&gt;sampling&lt;/em&gt; dependence clones and for &lt;em&gt;estimating&lt;/em&gt; parameters of the whole
clone population.&lt;/p&gt;
&lt;p&gt;We present &lt;a href="https://github.com/timtadh/graple"&gt;GRAPLE (GRAph samPLE)&lt;/a&gt;, a method
to generate a representative sample of recurring subgraphs of any directed
labeled graph(s). It can be used to sample subgraphs from any kind of program
graph representation.  &lt;code&gt;GRAPLE&lt;/code&gt; is not a general purpose clone detector but it
can answer questions about dependence clones that other PDG-based clone
detection tools cannot.  We conducted a preliminary case study on a commercial
application and had its developers evaluate whether the sampled subgraphs
represented code duplication.  To our knowledge, it is the first study to have
professional programmers examine dependence clones.  &lt;code&gt;GRAPLE&lt;/code&gt; has applications
in bug mining, test case selection, and bioinformatics. The sampling algorithm
also applies to frequent item sets, subsequences, and subtrees allowing code
clone sampling from tokens and ASTs.&lt;/p&gt;
&lt;h4&gt;Note&lt;/h4&gt;
&lt;p&gt;See the &lt;a href="http://hackthology.com/pdfs/swan-2016.pdf"&gt;PDF&lt;/a&gt; for the complete paper. ACM
has the exclusive rights to publish this paper. Tim Henderson and Andy Podgurski
own the copyright. Follow the &lt;a href="https://dx.doi.org/10.1145/2989238.2989241"&gt;DOI&lt;/a&gt;
for the ACM copy. This copy is posted here with the permission of ACM.&lt;/p&gt;</summary></entry></feed>