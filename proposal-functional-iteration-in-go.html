<!DOCTYPE html>
<html lang="en">
  <head>
        <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=endge, chrome=IE8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width, user-scalable=no" />
    <title>Hackthology</title>
    <link href='http://fonts.googleapis.com/css?family=Alice' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Lora:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
    <!--[if lte IE 8]><script type="text/javascript" src="http://hackthology.com/theme/js/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" type="text/css" href="http://hackthology.com/theme/css/skeleton.css" />
    <link rel="stylesheet" type="text/css" href="http://hackthology.com/theme/css/theme.css" />
    <link rel="shortcut icon" type="image/png" href="http://hackthology.com/favicon.png" />
    <!--[if lte IE 8]><link rel="shortcut icon" type="image/x-icon" href="http://hackthology.com/favicon.ico" /><![endif]-->
    <link rel="alternate" type="application/atom+xml"
                           title="Hackthology — Flux Atom"
                           href="http://hackthology.com/" /> 
    <link rel ="alternate" type="application/rss+xml"
                           title="Hackthology — Flux RSS"
                           href="http://hackthology.com/feeds/rss.xml" /> 

    <meta name="author"   content="Tim Henderson" />
    <meta name="keywords" content="" />
    <link rel="stylesheet" media="not print" type="text/css" href="http://hackthology.com/theme/css/pygments.css" /> 
  </head>
  <body>
    <div id="page">
      <header id="page-head">
        <h1>
          <a href="http://hackthology.com/index.html">Hackthology</a>
        </h1>
        <div class="top-nav">
          <ul>
            <li><a href="http://hackthology.com/pages/about.html">about</a></li>
            <li><a href="http://hackthology.com/pages/consulting.html">consulting</a></li>
            <li><a href="http://hackthology.com/pages/projects.html">projects</a></li>
            <li><a href="http://hackthology.com/pages/research.html">research</a></li>
            <li><a href="http://hackthology.com/pages/teaching.html">teaching</a></li>
          </ul>
        </div>
      </header>
      
      <div id="page-body">

        <article class="post" id="page-main" role="main">
      <header class="post-header">
        <h1 class="full">
          <a rel="bookmark"
             href="http://hackthology.com/proposal-functional-iteration-in-go.html"
             title="perm link Proposal: Functional Iteration in Go">
             Proposal: Functional Iteration in Go
          </a>
        </h1>
        <div class="meta">
<!-- includes/article_meta.html -->
          <div class="meta">
            by <a href="http://hackthology.com/pages/about.html">Tim Henderson</a>
            <br/> <time datetime="2013-12-13T00:00:00">Fri 13 December 2013</time></div>        </div>
      </header>
      <div class="post-content"> 
        <p>Go provides a built in way to iterate easily over built-in collection types:
<code>maps</code>, <code>slices</code> and <code>chans</code>. Iterating with these types much like iterating
using for-each type loops in languages Python, Ruby and Java.</p>
<div class="highlight"><pre><span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="kd">map</span> <span class="p">{</span>
    <span class="c1">// key, value</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
    <span class="c1">// index, item</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">channel</span> <span class="p">{</span>
    <span class="c1">// item</span>
<span class="p">}</span>
</pre></div>


<p>Unfortunately, Go does not provide a way to iterate over user defined
collections using range. I have been experimenting with how to solve this
problem since the initial public release of Go and I have finally settled on a
solution I like. This new solution uses a functional programming style.</p>
<h2>Functional Iterators</h2>
<div class="highlight"><pre><span class="kd">type</span> <span class="nx">Iterator</span> <span class="kd">func</span><span class="p">()(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">next</span> <span class="nx">Iterator</span><span class="p">)</span>
</pre></div>


<p>An iterator is function. Calling the function yields the next item in the
collection and a continuation function pointer. When the continuation function
pointer becomes nil, there are no more items left in the collection. Here's an
example of how to use a functional iterator from a test case in my
<a href="https://github.com/timtadh/data-structures/blob/ab3c41d91c7b569caa0e989c7787de16cca7d10b/tree/avltree_test.go#L206">data-structures repository</a>:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">next</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">Iterate</span><span class="p">()();</span> <span class="nx">next</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">next</span> <span class="p">=</span> <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">k</span><span class="p">.</span><span class="nx">Equals</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Int</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">j</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&quot;Wrong key&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">v</span><span class="p">.(</span><span class="kt">int</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">j</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="s">&quot;Wrong value&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">j</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>


<p>The functional approach allows the user to have a nice "linked-list" style
interface while avoiding the problems with using channels to implement
iteration. Using channels make iterators quite easy to write, consider this
post-order traversal:</p>
<div class="highlight"><pre><span class="kd">func</span> <span class="nx">PostOrder</span><span class="p">(</span><span class="nx">node</span> <span class="nx">Node</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">PostOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">(),</span> <span class="nx">out</span><span class="p">)</span>
    <span class="nx">PostOrder</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">(),</span> <span class="nx">out</span><span class="p">)</span>
    <span class="nx">out</span><span class="o">&lt;-</span><span class="nx">node</span><span class="p">.</span><span class="nx">Value</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>


<p>n
    // using it
    iter := make(chan interface{})
    go PostOrder(root, iter)
    for node := range iter {
        // do something with node
    }</p>
<p>However, what happens if the consumer of the iterator needs to bail out early?
Like so:</p>
<div class="highlight"><pre><span class="nx">iter</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">interface</span><span class="p">{})</span>
<span class="k">go</span> <span class="nx">PostOrder</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">iter</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">IsBad</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// do something with node</span>
<span class="p">}</span>
</pre></div>


<p>In this case the go-routine <code>PostOrder</code> is running in will leak. Since, it will
be blocked on sending to the consumer who will never consume the item. The fix
for this is to make the API more complicated by adding two way communication
such that the consuming thread can indicate to the producing thread it no longer
wants any more items. This can be a significant complication as it would be in
the cute little post-order traversal presented above.</p>
<h2>Functional Iteration to the Rescue (almost)</h2>
<p>Functional iteration solves several of the problems with iterating using
channels while maintaining an easy to use interface. Because all the code runs
on the same go-routine no go-routines can leak. If a consumer stops using an
iterator the garbage collector can clean it up. In the <code>PostOrder</code> traversal
above the channel can leak because the producing go-routine maintains a
reference. However, functional iterators are a bit tricky to write. Let's look
at a few from the <a href="https://github.com/timtadh/data-structures">data-structures
repository</a>.</p>
<h3>Hash Table Iteration.</h3>
<div class="highlight"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Hash</span><span class="p">)</span> <span class="nx">Iterate</span><span class="p">()</span> <span class="nx">KVIterator</span> <span class="p">{</span>
    <span class="nx">table</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">table</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">e</span> <span class="o">*</span><span class="nx">entry</span>
    <span class="kd">var</span> <span class="nx">kv_iterator</span> <span class="nx">KVIterator</span>
    <span class="nx">kv_iterator</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()(</span><span class="nx">key</span> <span class="nx">Equatable</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">next</span> <span class="nx">KVIterator</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">e</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">i</span><span class="o">++</span>
            <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">table</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
            <span class="p">}</span>
            <span class="nx">e</span> <span class="p">=</span> <span class="nx">table</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="nx">key</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">key</span>
        <span class="nx">val</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">value</span>
        <span class="nx">e</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">return</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">kv_iterator</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">kv_iterator</span>
<span class="p">}</span>
</pre></div>


<p>How does the function work? The first thing to notice is the <code>Iterate</code> function
returns a function <code>kv_iterator</code> which closes over some state: <code>table</code>, <code>i</code> and
<code>e</code>. The <code>table</code> variable is the array backing the hash table. The <code>i</code> variable
refers to which bucket is currently being examined. Finally, the <code>e</code> variable
refers to which entry in the bucket is next to be returned to the consumer.</p>
<p>When the consumer calls the <code>kv_iterator</code> function for the first time <code>e</code> will
be <code>nil</code> and the top loop will run until and entry is found or it has run
through the entire table. When and entry is found, the key and value are stored
and <code>e</code> is set to <code>e.next</code>. This assignment modifies the closed state of
<code>kv_iterator</code> and will be preserved on the next call to <code>kv_iterator</code>. Finally,
<code>key</code>, <code>val</code> and <code>kv_iterator</code> are returned to the consumer.</p>
<p>The main thing to understand about the <code>kv_iterator</code> function and all iterators
of this style is they implement a tail-recursive approach to iteration. Thus,
just like writing a tail-recursive function in Scheme or Lisp one must write the
iterator such that no actions need to be taken after the data is returned to the
user. This sometimes gets tricky, for instance in post-order iteration.</p>
<h3>Post Order Iteration</h3>
<div class="highlight"><pre><span class="kd">func</span> <span class="nx">TraverseTreePostOrder</span><span class="p">(</span><span class="nx">node</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TreeNodeIterator</span> <span class="p">{</span>
    <span class="kd">type</span> <span class="nx">entry</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">tn</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TreeNode</span>
        <span class="nx">i</span> <span class="kt">int</span>
    <span class="p">}</span>

    <span class="nx">pop</span> <span class="o">:=</span> <span class="kd">func</span> <span class="p">(</span><span class="nx">stack</span> <span class="p">[]</span><span class="nx">entry</span><span class="p">)</span> <span class="p">([]</span><span class="nx">entry</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">stack</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">e</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">e</span><span class="p">.</span><span class="nx">tn</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="nx">stack</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="nx">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="nx">entry</span><span class="p">{</span><span class="nx">tn_expose_nil</span><span class="p">(</span><span class="nx">node</span><span class="p">),</span> <span class="mi">0</span><span class="p">})</span>

    <span class="kd">var</span> <span class="nx">tn_iterator</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TreeNodeIterator</span>
    <span class="nx">tn_iterator</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()(</span><span class="nx">tn</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">next</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TreeNodeIterator</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
        <span class="p">}</span>

        <span class="nx">stack</span><span class="p">,</span> <span class="nx">tn</span><span class="p">,</span> <span class="nx">i</span> <span class="p">=</span> <span class="nx">pop</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">tn</span><span class="p">.</span><span class="nx">ChildCount</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">kid</span> <span class="o">:=</span> <span class="nx">tn</span><span class="p">.</span><span class="nx">GetChild</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
            <span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">entry</span><span class="p">{</span><span class="nx">tn</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">})</span>
            <span class="nx">tn</span> <span class="p">=</span> <span class="nx">kid</span>
            <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">tn</span><span class="p">,</span> <span class="nx">tn_iterator</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">tn_iterator</span>
<span class="p">}</span>
</pre></div>


<p>This time, the iterator must keep a stack of items in order to function. The
top entry contains the next item to process and location in its child list next
to process. The function pops a node, <code>tn</code>, and child index, <code>i</code>, off of the
stack. If the node, <code>tn</code>, has unprocessed children it gets the next child, and
pushes <code>tn</code> back onto the stack (and increments <code>i</code>). The child then becomes
<code>tn</code>. It continues traversing down the left most side of the tree until it gets
to a leaf node. At that point, the function exits the loop and returns the final
value for <code>tn</code> and the <code>tn_iterator</code>.</p>
<p>The next time the function is called, it will pop the stack and find the parent
of the last node it returned to the consumer. If there are more children of
parent left to processed it will repeat the process described above. Otherwise,
the parent gets returned to the consumer and the stack shrinks.</p>
<h2>Conclusion</h2>
<p>Functional iterators represent a flexible way to implement generic iterators in
Go. They are easy to use and do not leak resources. There only draw back in
comparison to other approaches is greater difficulty in constructing the
iterators. In order solve this libraries of data-structures and iterator
generators should be constructed. I have begun such a library in my
<a href="https://github.com/timtadh/data-structures">data-structures repository</a>.</p>
      </div>
      </article> <!-- /#page-main -->

        <aside id="page-side">
          <!-- begin includes/sidebar.html -->
          <nav>
            <h3 class="first"><a href="http://hackthology.com/index.html">hackthology/</a></h3>
            <h3>pages/</h3>
            <ul>
              <li><a href="http://hackthology.com/pages/about.html">about/</a></li>
              <li><a href="http://hackthology.com/pages/consulting.html">consulting/</a></li>
              <li><a href="http://hackthology.com/pages/projects.html">projects/</a></li>
              <li><a href="http://hackthology.com/pages/research.html">research/</a></li>
              <li><a href="http://hackthology.com/pages/teaching.html">teaching/</a></li>
            </ul>
          </nav>

          <nav>
              <h3 class="active"><a href="http://hackthology.com/category/blog.html">blog/</a></h3>
          </nav>

          <nav>
            <h3>links/</h3>
            <ul>
              <li><a href="http://hackthology.com/feeds/rss.xml">rss-feed/</a></li>
              <li><a href="https://github.com/timtadh">github.com/timtadh/</a></li>
              <li><a href="https://twitter.com/timtadh">twitter.com/timtadh/</a></li>
              <li><a href="https://plus.google.com/109232399292705173597">google+/</a></li>
            </ul>
          </nav>
          <!-- end includes/sidebar.html --></aside> <!-- /#page-side -->
      </div>  <!-- /#page-body -->

      <footer id="page-foot">
        <p> Powered by <a href="http://pelican.readthedocs.org">Pelican</a></p>
      </footer>
    </div> <!-- /#page -->
    <script type="text/javascript">
      var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-20145944-2']);
          _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); 
        ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>